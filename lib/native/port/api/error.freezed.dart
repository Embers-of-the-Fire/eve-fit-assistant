// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'error.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$ErrorKey {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) =>
      throw _privateConstructorUsedError;

  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ErrorKeyCopyWith<$Res> {
  factory $ErrorKeyCopyWith(ErrorKey value, $Res Function(ErrorKey) then) =
      _$ErrorKeyCopyWithImpl<$Res, ErrorKey>;
}

/// @nodoc
class _$ErrorKeyCopyWithImpl<$Res, $Val extends ErrorKey> implements $ErrorKeyCopyWith<$Res> {
  _$ErrorKeyCopyWithImpl(this._value, this._then);

// ignore: unused_field
  final $Val _value;
// ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$ErrorKey_IncompatibleChargeSizeImplCopyWith<$Res> {
  factory _$$ErrorKey_IncompatibleChargeSizeImplCopyWith(
          _$ErrorKey_IncompatibleChargeSizeImpl value,
          $Res Function(_$ErrorKey_IncompatibleChargeSizeImpl) then) =
      __$$ErrorKey_IncompatibleChargeSizeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int expected, int actual});
}

/// @nodoc
class __$$ErrorKey_IncompatibleChargeSizeImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_IncompatibleChargeSizeImpl>
    implements _$$ErrorKey_IncompatibleChargeSizeImplCopyWith<$Res> {
  __$$ErrorKey_IncompatibleChargeSizeImplCopyWithImpl(_$ErrorKey_IncompatibleChargeSizeImpl _value,
      $Res Function(_$ErrorKey_IncompatibleChargeSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$ErrorKey_IncompatibleChargeSizeImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as int,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ErrorKey_IncompatibleChargeSizeImpl extends ErrorKey_IncompatibleChargeSize {
  const _$ErrorKey_IncompatibleChargeSizeImpl({required this.expected, required this.actual})
      : super._();

  @override
  final int expected;
  @override
  final int actual;

  @override
  String toString() {
    return 'ErrorKey.incompatibleChargeSize(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_IncompatibleChargeSizeImpl &&
            (identical(other.expected, expected) || other.expected == expected) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, actual);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_IncompatibleChargeSizeImplCopyWith<_$ErrorKey_IncompatibleChargeSizeImpl>
      get copyWith => __$$ErrorKey_IncompatibleChargeSizeImplCopyWithImpl<
          _$ErrorKey_IncompatibleChargeSizeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return incompatibleChargeSize(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return incompatibleChargeSize?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleChargeSize != null) {
      return incompatibleChargeSize(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return incompatibleChargeSize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return incompatibleChargeSize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleChargeSize != null) {
      return incompatibleChargeSize(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_IncompatibleChargeSize extends ErrorKey {
  const factory ErrorKey_IncompatibleChargeSize(
      {required final int expected,
      required final int actual}) = _$ErrorKey_IncompatibleChargeSizeImpl;
  const ErrorKey_IncompatibleChargeSize._() : super._();

  int get expected;
  int get actual;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_IncompatibleChargeSizeImplCopyWith<_$ErrorKey_IncompatibleChargeSizeImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_IncompatibleChargeCapacityImplCopyWith<$Res> {
  factory _$$ErrorKey_IncompatibleChargeCapacityImplCopyWith(
          _$ErrorKey_IncompatibleChargeCapacityImpl value,
          $Res Function(_$ErrorKey_IncompatibleChargeCapacityImpl) then) =
      __$$ErrorKey_IncompatibleChargeCapacityImplCopyWithImpl<$Res>;
  @useResult
  $Res call({double max, double actual});
}

/// @nodoc
class __$$ErrorKey_IncompatibleChargeCapacityImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_IncompatibleChargeCapacityImpl>
    implements _$$ErrorKey_IncompatibleChargeCapacityImplCopyWith<$Res> {
  __$$ErrorKey_IncompatibleChargeCapacityImplCopyWithImpl(
      _$ErrorKey_IncompatibleChargeCapacityImpl _value,
      $Res Function(_$ErrorKey_IncompatibleChargeCapacityImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? max = null,
    Object? actual = null,
  }) {
    return _then(_$ErrorKey_IncompatibleChargeCapacityImpl(
      max: null == max
          ? _value.max
          : max // ignore: cast_nullable_to_non_nullable
              as double,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as double,
    ));
  }
}

/// @nodoc

class _$ErrorKey_IncompatibleChargeCapacityImpl extends ErrorKey_IncompatibleChargeCapacity {
  const _$ErrorKey_IncompatibleChargeCapacityImpl({required this.max, required this.actual})
      : super._();

  @override
  final double max;
  @override
  final double actual;

  @override
  String toString() {
    return 'ErrorKey.incompatibleChargeCapacity(max: $max, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_IncompatibleChargeCapacityImpl &&
            (identical(other.max, max) || other.max == max) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, max, actual);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_IncompatibleChargeCapacityImplCopyWith<_$ErrorKey_IncompatibleChargeCapacityImpl>
      get copyWith => __$$ErrorKey_IncompatibleChargeCapacityImplCopyWithImpl<
          _$ErrorKey_IncompatibleChargeCapacityImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return incompatibleChargeCapacity(max, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return incompatibleChargeCapacity?.call(max, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleChargeCapacity != null) {
      return incompatibleChargeCapacity(max, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return incompatibleChargeCapacity(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return incompatibleChargeCapacity?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleChargeCapacity != null) {
      return incompatibleChargeCapacity(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_IncompatibleChargeCapacity extends ErrorKey {
  const factory ErrorKey_IncompatibleChargeCapacity(
      {required final double max,
      required final double actual}) = _$ErrorKey_IncompatibleChargeCapacityImpl;
  const ErrorKey_IncompatibleChargeCapacity._() : super._();

  double get max;
  double get actual;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_IncompatibleChargeCapacityImplCopyWith<_$ErrorKey_IncompatibleChargeCapacityImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_TooMuchTurretImplCopyWith<$Res> {
  factory _$$ErrorKey_TooMuchTurretImplCopyWith(
          _$ErrorKey_TooMuchTurretImpl value, $Res Function(_$ErrorKey_TooMuchTurretImpl) then) =
      __$$ErrorKey_TooMuchTurretImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int expected, int actual});
}

/// @nodoc
class __$$ErrorKey_TooMuchTurretImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_TooMuchTurretImpl>
    implements _$$ErrorKey_TooMuchTurretImplCopyWith<$Res> {
  __$$ErrorKey_TooMuchTurretImplCopyWithImpl(
      _$ErrorKey_TooMuchTurretImpl _value, $Res Function(_$ErrorKey_TooMuchTurretImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$ErrorKey_TooMuchTurretImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as int,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ErrorKey_TooMuchTurretImpl extends ErrorKey_TooMuchTurret {
  const _$ErrorKey_TooMuchTurretImpl({required this.expected, required this.actual}) : super._();

  @override
  final int expected;
  @override
  final int actual;

  @override
  String toString() {
    return 'ErrorKey.tooMuchTurret(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_TooMuchTurretImpl &&
            (identical(other.expected, expected) || other.expected == expected) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, actual);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_TooMuchTurretImplCopyWith<_$ErrorKey_TooMuchTurretImpl> get copyWith =>
      __$$ErrorKey_TooMuchTurretImplCopyWithImpl<_$ErrorKey_TooMuchTurretImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return tooMuchTurret(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return tooMuchTurret?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (tooMuchTurret != null) {
      return tooMuchTurret(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return tooMuchTurret(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return tooMuchTurret?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (tooMuchTurret != null) {
      return tooMuchTurret(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_TooMuchTurret extends ErrorKey {
  const factory ErrorKey_TooMuchTurret({required final int expected, required final int actual}) =
      _$ErrorKey_TooMuchTurretImpl;
  const ErrorKey_TooMuchTurret._() : super._();

  int get expected;
  int get actual;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_TooMuchTurretImplCopyWith<_$ErrorKey_TooMuchTurretImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_TooMuchLauncherImplCopyWith<$Res> {
  factory _$$ErrorKey_TooMuchLauncherImplCopyWith(_$ErrorKey_TooMuchLauncherImpl value,
          $Res Function(_$ErrorKey_TooMuchLauncherImpl) then) =
      __$$ErrorKey_TooMuchLauncherImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int expected, int actual});
}

/// @nodoc
class __$$ErrorKey_TooMuchLauncherImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_TooMuchLauncherImpl>
    implements _$$ErrorKey_TooMuchLauncherImplCopyWith<$Res> {
  __$$ErrorKey_TooMuchLauncherImplCopyWithImpl(
      _$ErrorKey_TooMuchLauncherImpl _value, $Res Function(_$ErrorKey_TooMuchLauncherImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$ErrorKey_TooMuchLauncherImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as int,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ErrorKey_TooMuchLauncherImpl extends ErrorKey_TooMuchLauncher {
  const _$ErrorKey_TooMuchLauncherImpl({required this.expected, required this.actual}) : super._();

  @override
  final int expected;
  @override
  final int actual;

  @override
  String toString() {
    return 'ErrorKey.tooMuchLauncher(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_TooMuchLauncherImpl &&
            (identical(other.expected, expected) || other.expected == expected) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, actual);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_TooMuchLauncherImplCopyWith<_$ErrorKey_TooMuchLauncherImpl> get copyWith =>
      __$$ErrorKey_TooMuchLauncherImplCopyWithImpl<_$ErrorKey_TooMuchLauncherImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return tooMuchLauncher(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return tooMuchLauncher?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (tooMuchLauncher != null) {
      return tooMuchLauncher(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return tooMuchLauncher(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return tooMuchLauncher?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (tooMuchLauncher != null) {
      return tooMuchLauncher(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_TooMuchLauncher extends ErrorKey {
  const factory ErrorKey_TooMuchLauncher({required final int expected, required final int actual}) =
      _$ErrorKey_TooMuchLauncherImpl;
  const ErrorKey_TooMuchLauncher._() : super._();

  int get expected;
  int get actual;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_TooMuchLauncherImplCopyWith<_$ErrorKey_TooMuchLauncherImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_ConflictItemImplCopyWith<$Res> {
  factory _$$ErrorKey_ConflictItemImplCopyWith(
          _$ErrorKey_ConflictItemImpl value, $Res Function(_$ErrorKey_ConflictItemImpl) then) =
      __$$ErrorKey_ConflictItemImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int groupId});
}

/// @nodoc
class __$$ErrorKey_ConflictItemImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_ConflictItemImpl>
    implements _$$ErrorKey_ConflictItemImplCopyWith<$Res> {
  __$$ErrorKey_ConflictItemImplCopyWithImpl(
      _$ErrorKey_ConflictItemImpl _value, $Res Function(_$ErrorKey_ConflictItemImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? groupId = null,
  }) {
    return _then(_$ErrorKey_ConflictItemImpl(
      groupId: null == groupId
          ? _value.groupId
          : groupId // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ErrorKey_ConflictItemImpl extends ErrorKey_ConflictItem {
  const _$ErrorKey_ConflictItemImpl({required this.groupId}) : super._();

  @override
  final int groupId;

  @override
  String toString() {
    return 'ErrorKey.conflictItem(groupId: $groupId)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_ConflictItemImpl &&
            (identical(other.groupId, groupId) || other.groupId == groupId));
  }

  @override
  int get hashCode => Object.hash(runtimeType, groupId);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_ConflictItemImplCopyWith<_$ErrorKey_ConflictItemImpl> get copyWith =>
      __$$ErrorKey_ConflictItemImplCopyWithImpl<_$ErrorKey_ConflictItemImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return conflictItem(groupId);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return conflictItem?.call(groupId);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (conflictItem != null) {
      return conflictItem(groupId);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return conflictItem(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return conflictItem?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (conflictItem != null) {
      return conflictItem(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_ConflictItem extends ErrorKey {
  const factory ErrorKey_ConflictItem({required final int groupId}) = _$ErrorKey_ConflictItemImpl;
  const ErrorKey_ConflictItem._() : super._();

  int get groupId;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_ConflictItemImplCopyWith<_$ErrorKey_ConflictItemImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_IncompatibleShipGroupImplCopyWith<$Res> {
  factory _$$ErrorKey_IncompatibleShipGroupImplCopyWith(_$ErrorKey_IncompatibleShipGroupImpl value,
          $Res Function(_$ErrorKey_IncompatibleShipGroupImpl) then) =
      __$$ErrorKey_IncompatibleShipGroupImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List expected});
}

/// @nodoc
class __$$ErrorKey_IncompatibleShipGroupImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_IncompatibleShipGroupImpl>
    implements _$$ErrorKey_IncompatibleShipGroupImplCopyWith<$Res> {
  __$$ErrorKey_IncompatibleShipGroupImplCopyWithImpl(_$ErrorKey_IncompatibleShipGroupImpl _value,
      $Res Function(_$ErrorKey_IncompatibleShipGroupImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
  }) {
    return _then(_$ErrorKey_IncompatibleShipGroupImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc

class _$ErrorKey_IncompatibleShipGroupImpl extends ErrorKey_IncompatibleShipGroup {
  const _$ErrorKey_IncompatibleShipGroupImpl({required this.expected}) : super._();

  @override
  final Int32List expected;

  @override
  String toString() {
    return 'ErrorKey.incompatibleShipGroup(expected: $expected)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_IncompatibleShipGroupImpl &&
            const DeepCollectionEquality().equals(other.expected, expected));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(expected));

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_IncompatibleShipGroupImplCopyWith<_$ErrorKey_IncompatibleShipGroupImpl>
      get copyWith =>
          __$$ErrorKey_IncompatibleShipGroupImplCopyWithImpl<_$ErrorKey_IncompatibleShipGroupImpl>(
              this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return incompatibleShipGroup(expected);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return incompatibleShipGroup?.call(expected);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleShipGroup != null) {
      return incompatibleShipGroup(expected);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return incompatibleShipGroup(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return incompatibleShipGroup?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleShipGroup != null) {
      return incompatibleShipGroup(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_IncompatibleShipGroup extends ErrorKey {
  const factory ErrorKey_IncompatibleShipGroup({required final Int32List expected}) =
      _$ErrorKey_IncompatibleShipGroupImpl;
  const ErrorKey_IncompatibleShipGroup._() : super._();

  Int32List get expected;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_IncompatibleShipGroupImplCopyWith<_$ErrorKey_IncompatibleShipGroupImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_IncompatibleShipTypeImplCopyWith<$Res> {
  factory _$$ErrorKey_IncompatibleShipTypeImplCopyWith(_$ErrorKey_IncompatibleShipTypeImpl value,
          $Res Function(_$ErrorKey_IncompatibleShipTypeImpl) then) =
      __$$ErrorKey_IncompatibleShipTypeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Int32List expected});
}

/// @nodoc
class __$$ErrorKey_IncompatibleShipTypeImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_IncompatibleShipTypeImpl>
    implements _$$ErrorKey_IncompatibleShipTypeImplCopyWith<$Res> {
  __$$ErrorKey_IncompatibleShipTypeImplCopyWithImpl(_$ErrorKey_IncompatibleShipTypeImpl _value,
      $Res Function(_$ErrorKey_IncompatibleShipTypeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
  }) {
    return _then(_$ErrorKey_IncompatibleShipTypeImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as Int32List,
    ));
  }
}

/// @nodoc

class _$ErrorKey_IncompatibleShipTypeImpl extends ErrorKey_IncompatibleShipType {
  const _$ErrorKey_IncompatibleShipTypeImpl({required this.expected}) : super._();

  @override
  final Int32List expected;

  @override
  String toString() {
    return 'ErrorKey.incompatibleShipType(expected: $expected)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_IncompatibleShipTypeImpl &&
            const DeepCollectionEquality().equals(other.expected, expected));
  }

  @override
  int get hashCode => Object.hash(runtimeType, const DeepCollectionEquality().hash(expected));

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_IncompatibleShipTypeImplCopyWith<_$ErrorKey_IncompatibleShipTypeImpl> get copyWith =>
      __$$ErrorKey_IncompatibleShipTypeImplCopyWithImpl<_$ErrorKey_IncompatibleShipTypeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return incompatibleShipType(expected);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return incompatibleShipType?.call(expected);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleShipType != null) {
      return incompatibleShipType(expected);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return incompatibleShipType(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return incompatibleShipType?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleShipType != null) {
      return incompatibleShipType(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_IncompatibleShipType extends ErrorKey {
  const factory ErrorKey_IncompatibleShipType({required final Int32List expected}) =
      _$ErrorKey_IncompatibleShipTypeImpl;
  const ErrorKey_IncompatibleShipType._() : super._();

  Int32List get expected;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_IncompatibleShipTypeImplCopyWith<_$ErrorKey_IncompatibleShipTypeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorKey_IncompatibleRigSizeImplCopyWith<$Res> {
  factory _$$ErrorKey_IncompatibleRigSizeImplCopyWith(_$ErrorKey_IncompatibleRigSizeImpl value,
          $Res Function(_$ErrorKey_IncompatibleRigSizeImpl) then) =
      __$$ErrorKey_IncompatibleRigSizeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int expected, int actual});
}

/// @nodoc
class __$$ErrorKey_IncompatibleRigSizeImplCopyWithImpl<$Res>
    extends _$ErrorKeyCopyWithImpl<$Res, _$ErrorKey_IncompatibleRigSizeImpl>
    implements _$$ErrorKey_IncompatibleRigSizeImplCopyWith<$Res> {
  __$$ErrorKey_IncompatibleRigSizeImplCopyWithImpl(_$ErrorKey_IncompatibleRigSizeImpl _value,
      $Res Function(_$ErrorKey_IncompatibleRigSizeImpl) _then)
      : super(_value, _then);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? expected = null,
    Object? actual = null,
  }) {
    return _then(_$ErrorKey_IncompatibleRigSizeImpl(
      expected: null == expected
          ? _value.expected
          : expected // ignore: cast_nullable_to_non_nullable
              as int,
      actual: null == actual
          ? _value.actual
          : actual // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ErrorKey_IncompatibleRigSizeImpl extends ErrorKey_IncompatibleRigSize {
  const _$ErrorKey_IncompatibleRigSizeImpl({required this.expected, required this.actual})
      : super._();

  @override
  final int expected;
  @override
  final int actual;

  @override
  String toString() {
    return 'ErrorKey.incompatibleRigSize(expected: $expected, actual: $actual)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorKey_IncompatibleRigSizeImpl &&
            (identical(other.expected, expected) || other.expected == expected) &&
            (identical(other.actual, actual) || other.actual == actual));
  }

  @override
  int get hashCode => Object.hash(runtimeType, expected, actual);

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorKey_IncompatibleRigSizeImplCopyWith<_$ErrorKey_IncompatibleRigSizeImpl> get copyWith =>
      __$$ErrorKey_IncompatibleRigSizeImplCopyWithImpl<_$ErrorKey_IncompatibleRigSizeImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(int expected, int actual) incompatibleChargeSize,
    required TResult Function(double max, double actual) incompatibleChargeCapacity,
    required TResult Function(int expected, int actual) tooMuchTurret,
    required TResult Function(int expected, int actual) tooMuchLauncher,
    required TResult Function(int groupId) conflictItem,
    required TResult Function(Int32List expected) incompatibleShipGroup,
    required TResult Function(Int32List expected) incompatibleShipType,
    required TResult Function(int expected, int actual) incompatibleRigSize,
  }) {
    return incompatibleRigSize(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(int expected, int actual)? incompatibleChargeSize,
    TResult? Function(double max, double actual)? incompatibleChargeCapacity,
    TResult? Function(int expected, int actual)? tooMuchTurret,
    TResult? Function(int expected, int actual)? tooMuchLauncher,
    TResult? Function(int groupId)? conflictItem,
    TResult? Function(Int32List expected)? incompatibleShipGroup,
    TResult? Function(Int32List expected)? incompatibleShipType,
    TResult? Function(int expected, int actual)? incompatibleRigSize,
  }) {
    return incompatibleRigSize?.call(expected, actual);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(int expected, int actual)? incompatibleChargeSize,
    TResult Function(double max, double actual)? incompatibleChargeCapacity,
    TResult Function(int expected, int actual)? tooMuchTurret,
    TResult Function(int expected, int actual)? tooMuchLauncher,
    TResult Function(int groupId)? conflictItem,
    TResult Function(Int32List expected)? incompatibleShipGroup,
    TResult Function(Int32List expected)? incompatibleShipType,
    TResult Function(int expected, int actual)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleRigSize != null) {
      return incompatibleRigSize(expected, actual);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ErrorKey_IncompatibleChargeSize value) incompatibleChargeSize,
    required TResult Function(ErrorKey_IncompatibleChargeCapacity value) incompatibleChargeCapacity,
    required TResult Function(ErrorKey_TooMuchTurret value) tooMuchTurret,
    required TResult Function(ErrorKey_TooMuchLauncher value) tooMuchLauncher,
    required TResult Function(ErrorKey_ConflictItem value) conflictItem,
    required TResult Function(ErrorKey_IncompatibleShipGroup value) incompatibleShipGroup,
    required TResult Function(ErrorKey_IncompatibleShipType value) incompatibleShipType,
    required TResult Function(ErrorKey_IncompatibleRigSize value) incompatibleRigSize,
  }) {
    return incompatibleRigSize(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult? Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult? Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult? Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult? Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult? Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult? Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult? Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
  }) {
    return incompatibleRigSize?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ErrorKey_IncompatibleChargeSize value)? incompatibleChargeSize,
    TResult Function(ErrorKey_IncompatibleChargeCapacity value)? incompatibleChargeCapacity,
    TResult Function(ErrorKey_TooMuchTurret value)? tooMuchTurret,
    TResult Function(ErrorKey_TooMuchLauncher value)? tooMuchLauncher,
    TResult Function(ErrorKey_ConflictItem value)? conflictItem,
    TResult Function(ErrorKey_IncompatibleShipGroup value)? incompatibleShipGroup,
    TResult Function(ErrorKey_IncompatibleShipType value)? incompatibleShipType,
    TResult Function(ErrorKey_IncompatibleRigSize value)? incompatibleRigSize,
    required TResult orElse(),
  }) {
    if (incompatibleRigSize != null) {
      return incompatibleRigSize(this);
    }
    return orElse();
  }
}

abstract class ErrorKey_IncompatibleRigSize extends ErrorKey {
  const factory ErrorKey_IncompatibleRigSize(
      {required final int expected,
      required final int actual}) = _$ErrorKey_IncompatibleRigSizeImpl;
  const ErrorKey_IncompatibleRigSize._() : super._();

  int get expected;
  int get actual;

  /// Create a copy of ErrorKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorKey_IncompatibleRigSizeImplCopyWith<_$ErrorKey_IncompatibleRigSizeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$SlotInfo {
  SlotType get slot => throw _privateConstructorUsedError;
  int? get index => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SlotType slot, int? index, ErrorKey errorKey) error,
    required TResult Function(SlotType slot, int? index, WarningKey warningKey) warning,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult? Function(SlotType slot, int? index, WarningKey warningKey)? warning,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult Function(SlotType slot, int? index, WarningKey warningKey)? warning,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SlotInfo_Error value) error,
    required TResult Function(SlotInfo_Warning value) warning,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SlotInfo_Error value)? error,
    TResult? Function(SlotInfo_Warning value)? warning,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SlotInfo_Error value)? error,
    TResult Function(SlotInfo_Warning value)? warning,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $SlotInfoCopyWith<SlotInfo> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $SlotInfoCopyWith<$Res> {
  factory $SlotInfoCopyWith(SlotInfo value, $Res Function(SlotInfo) then) =
      _$SlotInfoCopyWithImpl<$Res, SlotInfo>;
  @useResult
  $Res call({SlotType slot, int? index});
}

/// @nodoc
class _$SlotInfoCopyWithImpl<$Res, $Val extends SlotInfo> implements $SlotInfoCopyWith<$Res> {
  _$SlotInfoCopyWithImpl(this._value, this._then);

// ignore: unused_field
  final $Val _value;
// ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? slot = null,
    Object? index = freezed,
  }) {
    return _then(_value.copyWith(
      slot: null == slot
          ? _value.slot
          : slot // ignore: cast_nullable_to_non_nullable
              as SlotType,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$SlotInfo_ErrorImplCopyWith<$Res> implements $SlotInfoCopyWith<$Res> {
  factory _$$SlotInfo_ErrorImplCopyWith(
          _$SlotInfo_ErrorImpl value, $Res Function(_$SlotInfo_ErrorImpl) then) =
      __$$SlotInfo_ErrorImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({SlotType slot, int? index, ErrorKey errorKey});

  $ErrorKeyCopyWith<$Res> get errorKey;
}

/// @nodoc
class __$$SlotInfo_ErrorImplCopyWithImpl<$Res>
    extends _$SlotInfoCopyWithImpl<$Res, _$SlotInfo_ErrorImpl>
    implements _$$SlotInfo_ErrorImplCopyWith<$Res> {
  __$$SlotInfo_ErrorImplCopyWithImpl(
      _$SlotInfo_ErrorImpl _value, $Res Function(_$SlotInfo_ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? slot = null,
    Object? index = freezed,
    Object? errorKey = null,
  }) {
    return _then(_$SlotInfo_ErrorImpl(
      slot: null == slot
          ? _value.slot
          : slot // ignore: cast_nullable_to_non_nullable
              as SlotType,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      errorKey: null == errorKey
          ? _value.errorKey
          : errorKey // ignore: cast_nullable_to_non_nullable
              as ErrorKey,
    ));
  }

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $ErrorKeyCopyWith<$Res> get errorKey {
    return $ErrorKeyCopyWith<$Res>(_value.errorKey, (value) {
      return _then(_value.copyWith(errorKey: value));
    });
  }
}

/// @nodoc

class _$SlotInfo_ErrorImpl extends SlotInfo_Error {
  const _$SlotInfo_ErrorImpl({required this.slot, this.index, required this.errorKey}) : super._();

  @override
  final SlotType slot;
  @override
  final int? index;
  @override
  final ErrorKey errorKey;

  @override
  String toString() {
    return 'SlotInfo.error(slot: $slot, index: $index, errorKey: $errorKey)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SlotInfo_ErrorImpl &&
            (identical(other.slot, slot) || other.slot == slot) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.errorKey, errorKey) || other.errorKey == errorKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, slot, index, errorKey);

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SlotInfo_ErrorImplCopyWith<_$SlotInfo_ErrorImpl> get copyWith =>
      __$$SlotInfo_ErrorImplCopyWithImpl<_$SlotInfo_ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SlotType slot, int? index, ErrorKey errorKey) error,
    required TResult Function(SlotType slot, int? index, WarningKey warningKey) warning,
  }) {
    return error(slot, index, errorKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult? Function(SlotType slot, int? index, WarningKey warningKey)? warning,
  }) {
    return error?.call(slot, index, errorKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult Function(SlotType slot, int? index, WarningKey warningKey)? warning,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(slot, index, errorKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SlotInfo_Error value) error,
    required TResult Function(SlotInfo_Warning value) warning,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SlotInfo_Error value)? error,
    TResult? Function(SlotInfo_Warning value)? warning,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SlotInfo_Error value)? error,
    TResult Function(SlotInfo_Warning value)? warning,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class SlotInfo_Error extends SlotInfo {
  const factory SlotInfo_Error(
      {required final SlotType slot,
      final int? index,
      required final ErrorKey errorKey}) = _$SlotInfo_ErrorImpl;
  const SlotInfo_Error._() : super._();

  @override
  SlotType get slot;
  @override
  int? get index;
  ErrorKey get errorKey;

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SlotInfo_ErrorImplCopyWith<_$SlotInfo_ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$SlotInfo_WarningImplCopyWith<$Res> implements $SlotInfoCopyWith<$Res> {
  factory _$$SlotInfo_WarningImplCopyWith(
          _$SlotInfo_WarningImpl value, $Res Function(_$SlotInfo_WarningImpl) then) =
      __$$SlotInfo_WarningImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({SlotType slot, int? index, WarningKey warningKey});

  $WarningKeyCopyWith<$Res> get warningKey;
}

/// @nodoc
class __$$SlotInfo_WarningImplCopyWithImpl<$Res>
    extends _$SlotInfoCopyWithImpl<$Res, _$SlotInfo_WarningImpl>
    implements _$$SlotInfo_WarningImplCopyWith<$Res> {
  __$$SlotInfo_WarningImplCopyWithImpl(
      _$SlotInfo_WarningImpl _value, $Res Function(_$SlotInfo_WarningImpl) _then)
      : super(_value, _then);

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? slot = null,
    Object? index = freezed,
    Object? warningKey = null,
  }) {
    return _then(_$SlotInfo_WarningImpl(
      slot: null == slot
          ? _value.slot
          : slot // ignore: cast_nullable_to_non_nullable
              as SlotType,
      index: freezed == index
          ? _value.index
          : index // ignore: cast_nullable_to_non_nullable
              as int?,
      warningKey: null == warningKey
          ? _value.warningKey
          : warningKey // ignore: cast_nullable_to_non_nullable
              as WarningKey,
    ));
  }

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $WarningKeyCopyWith<$Res> get warningKey {
    return $WarningKeyCopyWith<$Res>(_value.warningKey, (value) {
      return _then(_value.copyWith(warningKey: value));
    });
  }
}

/// @nodoc

class _$SlotInfo_WarningImpl extends SlotInfo_Warning {
  const _$SlotInfo_WarningImpl({required this.slot, this.index, required this.warningKey})
      : super._();

  @override
  final SlotType slot;
  @override
  final int? index;
  @override
  final WarningKey warningKey;

  @override
  String toString() {
    return 'SlotInfo.warning(slot: $slot, index: $index, warningKey: $warningKey)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$SlotInfo_WarningImpl &&
            (identical(other.slot, slot) || other.slot == slot) &&
            (identical(other.index, index) || other.index == index) &&
            (identical(other.warningKey, warningKey) || other.warningKey == warningKey));
  }

  @override
  int get hashCode => Object.hash(runtimeType, slot, index, warningKey);

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$SlotInfo_WarningImplCopyWith<_$SlotInfo_WarningImpl> get copyWith =>
      __$$SlotInfo_WarningImplCopyWithImpl<_$SlotInfo_WarningImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(SlotType slot, int? index, ErrorKey errorKey) error,
    required TResult Function(SlotType slot, int? index, WarningKey warningKey) warning,
  }) {
    return warning(slot, index, warningKey);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult? Function(SlotType slot, int? index, WarningKey warningKey)? warning,
  }) {
    return warning?.call(slot, index, warningKey);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(SlotType slot, int? index, ErrorKey errorKey)? error,
    TResult Function(SlotType slot, int? index, WarningKey warningKey)? warning,
    required TResult orElse(),
  }) {
    if (warning != null) {
      return warning(slot, index, warningKey);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(SlotInfo_Error value) error,
    required TResult Function(SlotInfo_Warning value) warning,
  }) {
    return warning(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(SlotInfo_Error value)? error,
    TResult? Function(SlotInfo_Warning value)? warning,
  }) {
    return warning?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(SlotInfo_Error value)? error,
    TResult Function(SlotInfo_Warning value)? warning,
    required TResult orElse(),
  }) {
    if (warning != null) {
      return warning(this);
    }
    return orElse();
  }
}

abstract class SlotInfo_Warning extends SlotInfo {
  const factory SlotInfo_Warning(
      {required final SlotType slot,
      final int? index,
      required final WarningKey warningKey}) = _$SlotInfo_WarningImpl;
  const SlotInfo_Warning._() : super._();

  @override
  SlotType get slot;
  @override
  int? get index;
  WarningKey get warningKey;

  /// Create a copy of SlotInfo
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$SlotInfo_WarningImplCopyWith<_$SlotInfo_WarningImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WarningKey {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() missingCharge,
    required TResult Function(int field0) placeholder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? missingCharge,
    TResult? Function(int field0)? placeholder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? missingCharge,
    TResult Function(int field0)? placeholder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarningKey_MissingCharge value) missingCharge,
    required TResult Function(WarningKey_Placeholder value) placeholder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarningKey_MissingCharge value)? missingCharge,
    TResult? Function(WarningKey_Placeholder value)? placeholder,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarningKey_MissingCharge value)? missingCharge,
    TResult Function(WarningKey_Placeholder value)? placeholder,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WarningKeyCopyWith<$Res> {
  factory $WarningKeyCopyWith(WarningKey value, $Res Function(WarningKey) then) =
      _$WarningKeyCopyWithImpl<$Res, WarningKey>;
}

/// @nodoc
class _$WarningKeyCopyWithImpl<$Res, $Val extends WarningKey> implements $WarningKeyCopyWith<$Res> {
  _$WarningKeyCopyWithImpl(this._value, this._then);

// ignore: unused_field
  final $Val _value;
// ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of WarningKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$WarningKey_MissingChargeImplCopyWith<$Res> {
  factory _$$WarningKey_MissingChargeImplCopyWith(_$WarningKey_MissingChargeImpl value,
          $Res Function(_$WarningKey_MissingChargeImpl) then) =
      __$$WarningKey_MissingChargeImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WarningKey_MissingChargeImplCopyWithImpl<$Res>
    extends _$WarningKeyCopyWithImpl<$Res, _$WarningKey_MissingChargeImpl>
    implements _$$WarningKey_MissingChargeImplCopyWith<$Res> {
  __$$WarningKey_MissingChargeImplCopyWithImpl(
      _$WarningKey_MissingChargeImpl _value, $Res Function(_$WarningKey_MissingChargeImpl) _then)
      : super(_value, _then);

  /// Create a copy of WarningKey
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$WarningKey_MissingChargeImpl extends WarningKey_MissingCharge {
  const _$WarningKey_MissingChargeImpl() : super._();

  @override
  String toString() {
    return 'WarningKey.missingCharge()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$WarningKey_MissingChargeImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() missingCharge,
    required TResult Function(int field0) placeholder,
  }) {
    return missingCharge();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? missingCharge,
    TResult? Function(int field0)? placeholder,
  }) {
    return missingCharge?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? missingCharge,
    TResult Function(int field0)? placeholder,
    required TResult orElse(),
  }) {
    if (missingCharge != null) {
      return missingCharge();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarningKey_MissingCharge value) missingCharge,
    required TResult Function(WarningKey_Placeholder value) placeholder,
  }) {
    return missingCharge(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarningKey_MissingCharge value)? missingCharge,
    TResult? Function(WarningKey_Placeholder value)? placeholder,
  }) {
    return missingCharge?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarningKey_MissingCharge value)? missingCharge,
    TResult Function(WarningKey_Placeholder value)? placeholder,
    required TResult orElse(),
  }) {
    if (missingCharge != null) {
      return missingCharge(this);
    }
    return orElse();
  }
}

abstract class WarningKey_MissingCharge extends WarningKey {
  const factory WarningKey_MissingCharge() = _$WarningKey_MissingChargeImpl;
  const WarningKey_MissingCharge._() : super._();
}

/// @nodoc
abstract class _$$WarningKey_PlaceholderImplCopyWith<$Res> {
  factory _$$WarningKey_PlaceholderImplCopyWith(
          _$WarningKey_PlaceholderImpl value, $Res Function(_$WarningKey_PlaceholderImpl) then) =
      __$$WarningKey_PlaceholderImplCopyWithImpl<$Res>;
  @useResult
  $Res call({int field0});
}

/// @nodoc
class __$$WarningKey_PlaceholderImplCopyWithImpl<$Res>
    extends _$WarningKeyCopyWithImpl<$Res, _$WarningKey_PlaceholderImpl>
    implements _$$WarningKey_PlaceholderImplCopyWith<$Res> {
  __$$WarningKey_PlaceholderImplCopyWithImpl(
      _$WarningKey_PlaceholderImpl _value, $Res Function(_$WarningKey_PlaceholderImpl) _then)
      : super(_value, _then);

  /// Create a copy of WarningKey
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? field0 = null,
  }) {
    return _then(_$WarningKey_PlaceholderImpl(
      null == field0
          ? _value.field0
          : field0 // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$WarningKey_PlaceholderImpl extends WarningKey_Placeholder {
  const _$WarningKey_PlaceholderImpl(this.field0) : super._();

  @override
  final int field0;

  @override
  String toString() {
    return 'WarningKey.placeholder(field0: $field0)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WarningKey_PlaceholderImpl &&
            (identical(other.field0, field0) || other.field0 == field0));
  }

  @override
  int get hashCode => Object.hash(runtimeType, field0);

  /// Create a copy of WarningKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$WarningKey_PlaceholderImplCopyWith<_$WarningKey_PlaceholderImpl> get copyWith =>
      __$$WarningKey_PlaceholderImplCopyWithImpl<_$WarningKey_PlaceholderImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() missingCharge,
    required TResult Function(int field0) placeholder,
  }) {
    return placeholder(field0);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? missingCharge,
    TResult? Function(int field0)? placeholder,
  }) {
    return placeholder?.call(field0);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? missingCharge,
    TResult Function(int field0)? placeholder,
    required TResult orElse(),
  }) {
    if (placeholder != null) {
      return placeholder(field0);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(WarningKey_MissingCharge value) missingCharge,
    required TResult Function(WarningKey_Placeholder value) placeholder,
  }) {
    return placeholder(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(WarningKey_MissingCharge value)? missingCharge,
    TResult? Function(WarningKey_Placeholder value)? placeholder,
  }) {
    return placeholder?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(WarningKey_MissingCharge value)? missingCharge,
    TResult Function(WarningKey_Placeholder value)? placeholder,
    required TResult orElse(),
  }) {
    if (placeholder != null) {
      return placeholder(this);
    }
    return orElse();
  }
}

abstract class WarningKey_Placeholder extends WarningKey {
  const factory WarningKey_Placeholder(final int field0) = _$WarningKey_PlaceholderImpl;
  const WarningKey_Placeholder._() : super._();

  int get field0;

  /// Create a copy of WarningKey
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$WarningKey_PlaceholderImplCopyWith<_$WarningKey_PlaceholderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
